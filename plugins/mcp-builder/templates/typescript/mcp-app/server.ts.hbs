/**
 * {{appName}} MCP App Server
 * Generated by MCP Builder Plugin
 */
console.log("Starting {{appName}} MCP Server...");

import {
  registerAppTool,
  registerAppResource,
  RESOURCE_MIME_TYPE,
} from "@modelcontextprotocol/ext-apps/server";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { createMcpExpressApp } from "@modelcontextprotocol/sdk/server/express.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import type { CallToolResult, ReadResourceResult } from "@modelcontextprotocol/sdk/types.js";
import cors from "cors";
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";

// Works both from source (server.ts) and compiled (dist/server.js)
const DIST_DIR = import.meta.filename.endsWith(".ts")
  ? path.join(import.meta.dirname, "dist")
  : import.meta.dirname;

// ============================================================================
// Resource URIs
// ============================================================================
{{#each tools}}

const {{camelCase this.name}}ResourceUri = "ui://{{kebabCase this.name}}/app.html";
{{/each}}

// ============================================================================
// Server Factory
// ============================================================================

export function createServer(): McpServer {
  const server = new McpServer({
    name: "{{appName}}",
    version: "1.0.0",
  });
{{#each tools}}

  // ==========================================================================
  // Tool: {{this.name}}
  // ==========================================================================

  registerAppTool(
    server,
    "{{kebabCase this.name}}",
    {
      title: "{{this.title}}",
      description: "{{this.description}}",
      inputSchema: {
{{#each this.inputs}}
        {{this.name}}: z.{{this.zodType}}(){{#if this.description}}.describe("{{this.description}}"){{/if}},
{{/each}}
      },
      _meta: { ui: { resourceUri: {{camelCase this.name}}ResourceUri } },
    },
    async ({ {{#each this.inputs}}{{this.name}}{{#unless @last}}, {{/unless}}{{/each}} }): Promise<CallToolResult> => {
      try {
        // TODO: Implement your business logic here
        const result = {
{{#each this.inputs}}
          {{this.name}},
{{/each}}
          timestamp: new Date().toISOString(),
        };

        return {
          content: [{ type: "text", text: JSON.stringify(result) }],
          structuredContent: result,
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown error";
        return {
          content: [{ type: "text", text: JSON.stringify({ error: true, message }) }],
          isError: true,
        };
      }
    }
  );

  registerAppResource(
    server,
    {{camelCase this.name}}ResourceUri,
    {{camelCase this.name}}ResourceUri,
    { mimeType: RESOURCE_MIME_TYPE },
    async (): Promise<ReadResourceResult> => {
      const html = await fs.readFile(
        path.join(DIST_DIR, "{{kebabCase this.name}}", "{{kebabCase this.name}}.html"),
        "utf-8"
      );
      return {
        contents: [{ uri: {{camelCase this.name}}ResourceUri, mimeType: RESOURCE_MIME_TYPE, text: html }],
      };
    }
  );
{{/each}}

  return server;
}

// ============================================================================
// HTTP Server
// ============================================================================

const port = parseInt(process.env.PORT ?? "{{port}}", 10);

const app = createMcpExpressApp({ host: "0.0.0.0" });
app.use(cors());

app.all("/mcp", async (req, res) => {
  const server = createServer();
  const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: undefined,
  });

  res.on("close", () => {
    transport.close().catch(() => {});
    server.close().catch(() => {});
  });

  try {
    await server.connect(transport);
    await transport.handleRequest(req, res, req.body);
  } catch (error) {
    console.error("MCP error:", error);
    if (!res.headersSent) {
      res.status(500).json({
        jsonrpc: "2.0",
        error: { code: -32603, message: "Internal server error" },
        id: null,
      });
    }
  }
});

app.listen(port, () => {
  console.log(`{{appName}} listening on http://localhost:${port}/mcp`);
});
