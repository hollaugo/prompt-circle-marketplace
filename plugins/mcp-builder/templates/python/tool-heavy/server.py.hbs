"""
{{serverName}} - MCP Server (Tool-Heavy Pattern)
Generated by MCP Builder Plugin

Demonstrates the tool-heavy architecture with:
- Many tools organized by domain
- Business logic in separate modules
- Comprehensive prompts for complex workflows
"""

import os
import json
from typing import Optional, List
from dotenv import load_dotenv
from fastmcp import FastMCP
from pydantic import BaseModel, Field, ConfigDict

# Load environment
load_dotenv()

# Initialize MCP server
mcp = FastMCP("{{serverName}}")

# =============================================================================
# BUSINESS LOGIC IMPORTS
# Import your domain-specific modules here
# from src.market_data import MarketDataClient
# from src.analysis import Analyzer
# =============================================================================


# =============================================================================
# INPUT SCHEMAS
# Define Pydantic models for all tool inputs
# =============================================================================

class SearchInput(BaseModel):
    """Input for search operations."""
    query: str = Field(..., description="Search term or keyword")
    limit: int = Field(10, description="Maximum results to return (1-50)", ge=1, le=50)
    include_details: bool = Field(True, description="Include full details in results")

    model_config = ConfigDict(extra="forbid")


class GetDetailInput(BaseModel):
    """Input for getting item details."""
    id: str = Field(..., description="Unique identifier of the item")

    model_config = ConfigDict(extra="forbid")


class CompareInput(BaseModel):
    """Input for comparing multiple items."""
    ids: List[str] = Field(..., description="List of IDs to compare (2-5 items)", min_length=2, max_length=5)

    model_config = ConfigDict(extra="forbid")


# =============================================================================
# QUERY TOOLS (readOnlyHint: true)
# Tools that fetch data without modification
# =============================================================================

@mcp.tool()
def search_items(
    query: str,
    limit: int = 10,
    include_details: bool = True
) -> str:
    """Search for items matching your query.

    Returns items with full details by default. Use when the user wants
    to find specific items or explore available options.

    Args:
        query: Search term to match against item names and descriptions
        limit: Maximum number of results (1-50, default 10)
        include_details: Include full item details (default True)

    Returns:
        JSON array of matching items with their details
    """
    # Replace with your actual search logic
    results = [
        {"id": "1", "name": f"Item matching '{query}'", "details": "Full details here"}
    ]

    if not include_details:
        results = [{"id": r["id"], "name": r["name"]} for r in results]

    return json.dumps({"results": results, "count": len(results)}, indent=2)


@mcp.tool()
def get_item_detail(id: str) -> str:
    """Get complete details for a specific item.

    Returns comprehensive information including metadata, history,
    and related items. Use when the user asks for details about
    a specific item they've identified.

    Args:
        id: Unique identifier of the item

    Returns:
        JSON object with complete item details
    """
    # Replace with your actual lookup logic
    item = {
        "id": id,
        "name": f"Item {id}",
        "description": "Complete description",
        "metadata": {"created": "2025-01-01", "updated": "2025-01-15"},
        "related": ["item-2", "item-3"]
    }

    return json.dumps(item, indent=2)


@mcp.tool()
def compare_items(ids: List[str]) -> str:
    """Compare multiple items side by side.

    Creates a comparison table highlighting differences and similarities.
    Use when the user wants to evaluate options or make a decision
    between items.

    Args:
        ids: List of 2-5 item IDs to compare

    Returns:
        JSON object with side-by-side comparison
    """
    # Replace with your actual comparison logic
    comparison = {
        "items": [{"id": id, "name": f"Item {id}", "score": 85} for id in ids],
        "comparison_matrix": {
            "price": {id: f"${i*10}" for i, id in enumerate(ids)},
            "quality": {id: f"{80+i}%" for i, id in enumerate(ids)}
        },
        "recommendation": ids[0] if ids else None
    }

    return json.dumps(comparison, indent=2)


# =============================================================================
# MUTATION TOOLS (readOnlyHint: false)
# Tools that create or modify data
# =============================================================================

@mcp.tool()
def create_item(name: str, description: str = "") -> str:
    """Create a new item.

    Creates and saves a new item with the given name and description.
    Returns the created item with its assigned ID.

    Args:
        name: Name for the new item
        description: Optional description

    Returns:
        JSON object with the created item including its new ID
    """
    # Replace with your actual creation logic
    new_item = {
        "id": "new-123",
        "name": name,
        "description": description,
        "created": "2025-01-15T12:00:00Z"
    }

    return json.dumps(new_item, indent=2)


# =============================================================================
# RESOURCES
# Static or semi-static data for agent context
# =============================================================================

@mcp.resource("schema://data-model")
def get_data_model() -> str:
    """Data model schema for understanding the structure.

    Read this resource before querying to understand:
    - Available fields and their types
    - Relationships between entities
    - Valid values for enum fields
    """
    return """
# Data Model

## Item
- id: string (unique identifier)
- name: string (display name)
- description: string (detailed description)
- metadata: object
  - created: ISO datetime
  - updated: ISO datetime
- related: string[] (related item IDs)

## Valid Statuses
- active
- archived
- pending
    """


# =============================================================================
# PROMPTS
# Pre-built conversation templates for complex workflows
# =============================================================================

@mcp.prompt("comprehensive-analysis")
def comprehensive_analysis_prompt(item_id: str) -> str:
    """Generate a comprehensive analysis for an item.

    Use this prompt when the user wants a thorough evaluation
    including all available data points and comparisons.
    """
    return f"""Please perform a comprehensive analysis of item {item_id}:

1. First, get the item details using get_item_detail
2. Search for related items using search_items
3. Compare with top alternatives using compare_items
4. Provide a summary with:
   - Key strengths and weaknesses
   - Comparison to alternatives
   - Recommendation

Format your response with clear sections and bullet points."""


# =============================================================================
# CUSTOM ROUTES
# =============================================================================

from starlette.responses import JSONResponse

@mcp.custom_route("/health", methods=["GET"])
async def health_check(request):
    return JSONResponse({"status": "healthy", "server": "{{serverName}}"})


@mcp.custom_route("/info", methods=["GET"])
async def server_info(request):
    tools = ["search_items", "get_item_detail", "compare_items", "create_item"]
    prompts = ["comprehensive_analysis"]
    return JSONResponse({
        "name": "{{serverName}}",
        "version": "1.0.0",
        "pattern": "tool-heavy",
        "tools": {"count": len(tools), "list": tools},
        "prompts": {"count": len(prompts), "list": prompts}
    })


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    import uvicorn

    port = int(os.environ.get("PORT", 8000))
    host = os.environ.get("HOST", "0.0.0.0")

    print(f"""
{'='*50}
  {{serverName}} MCP Server
  Pattern: Tool-Heavy
{'='*50}
  Port:     {port}
  Tools:    4
  Prompts:  1
  Health:   http://{host}:{port}/health
  MCP:      http://{host}:{port}/mcp
{'='*50}
    """)

    app = mcp.http_app(path="/mcp")
    uvicorn.run(app, host=host, port=port)
